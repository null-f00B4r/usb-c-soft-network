# Configuration File Format

## File: `target_usb_c_port.env`

This file is generated by `scripts/identify-usb-c-port.sh` and contains the detected USB-C port configuration.

## Format Version: 1.0

### Common Fields (Both Methods)

```bash
DETECTION_METHOD=<sysfs|libusb>  # Which detection method was used
```

### Method 1: sysfs (Type-C Subsystem)

Generated when using the Type-C sysfs detection method:

```bash
# Target USB-C Port Configuration
# Generated by identify-usb-c-port.sh (sysfs method) on <timestamp>

DETECTION_METHOD=sysfs
TYPEC_PORT=port1                          # Port name (e.g., port0, port1)
TYPEC_PORT_PATH=/sys/class/typec/port1    # Full sysfs path
TYPEC_DATA_ROLE=host [device]             # Data role (host/device)
TYPEC_POWER_ROLE=source [sink]            # Power role (source/sink)
TYPEC_ORIENTATION=unknown                 # Cable orientation (normal/reverse/unknown)
USB_CONTROLLER=usb1                       # Associated USB controller (if detected)

# For monitoring connection state:
# cat /sys/class/typec/port1-partner 2>/dev/null && echo "Connected" || echo "Disconnected"

# For use in scripts:
# source target_usb_c_port.env
# if [[ -d $TYPEC_PORT_PATH-partner ]]; then
#     echo "USB-C cable connected on $TYPEC_PORT"
# fi
```

### Method 2: libusb (Device Enumeration)

Generated when using the libusb device enumeration method:

```bash
# Target USB-C Port Configuration
# Generated by identify-usb-c-port.sh (libusb method) on <timestamp>

DETECTION_METHOD=libusb
USB_BUS=002                               # USB bus number
USB_DEVICE=003                            # USB device number
USB_SPEED=480                             # USB speed in Mbps
USB_VENDOR_PRODUCT=1d6b:0002              # USB vendor:product ID
USB_DESCRIPTION="Linux Foundation 2.0 root hub"  # Device description

# Full device path for Docker passthrough
USB_DEVICE_PATH=/dev/bus/usb/002/003

# For use in scripts:
# source target_usb_c_port.env
# docker run --device=$USB_DEVICE_PATH ...
```

## Usage in Scripts

### Check which method was used:

```bash
source target_usb_c_port.env

if [[ "$DETECTION_METHOD" == "sysfs" ]]; then
    echo "Using Type-C sysfs detection"
    echo "Port: $TYPEC_PORT at $TYPEC_PORT_PATH"
    
    # Monitor connection state
    if [[ -d "$TYPEC_PORT_PATH-partner" ]]; then
        echo "Cable connected"
    else
        echo "Cable not connected"
    fi
    
elif [[ "$DETECTION_METHOD" == "libusb" ]]; then
    echo "Using libusb device enumeration"
    echo "Device: Bus $USB_BUS Device $USB_DEVICE"
    
    # Check if device is present
    if lsusb -s $USB_BUS:$USB_DEVICE &>/dev/null; then
        echo "Device present"
    else
        echo "Device not present"
    fi
fi
```

### Docker passthrough example:

```bash
source target_usb_c_port.env

if [[ "$DETECTION_METHOD" == "sysfs" ]]; then
    # For sysfs, find the USB device associated with the port
    # This requires additional logic to map sysfs port to USB device
    echo "Note: Docker passthrough works better with libusb method"
    
elif [[ "$DETECTION_METHOD" == "libusb" ]]; then
    # Direct device passthrough
    docker run --device=$USB_DEVICE_PATH my-container
fi
```

### Monitoring connection state:

```bash
source target_usb_c_port.env

if [[ "$DETECTION_METHOD" == "sysfs" ]]; then
    # Watch for cable connection/disconnection
    watch -n 1 "ls -ld $TYPEC_PORT_PATH-partner 2>/dev/null || echo 'Not connected'"
    
elif [[ "$DETECTION_METHOD" == "libusb" ]]; then
    # Watch for device presence
    watch -n 1 "lsusb -s $USB_BUS:$USB_DEVICE 2>/dev/null || echo 'Not present'"
fi
```

## Field Descriptions

### sysfs Method Fields

| Field | Type | Description | Possible Values |
|-------|------|-------------|-----------------|
| `DETECTION_METHOD` | string | Detection method used | `sysfs` |
| `TYPEC_PORT` | string | Type-C port name | `port0`, `port1`, ... |
| `TYPEC_PORT_PATH` | path | Full sysfs path to port | `/sys/class/typec/portN` |
| `TYPEC_DATA_ROLE` | string | USB data role | `host`, `device`, `[host] device`, `host [device]` |
| `TYPEC_POWER_ROLE` | string | USB-C power role | `source`, `sink`, `[source] sink`, `source [sink]` |
| `TYPEC_ORIENTATION` | string | Cable orientation | `normal`, `reverse`, `unknown` |
| `USB_CONTROLLER` | string | USB controller name | `usb1`, `usb2`, ..., `unknown` |

**Note**: Bracketed values like `[host] device` indicate the current state (in brackets) and supported modes.

### libusb Method Fields

| Field | Type | Description | Possible Values |
|-------|------|-------------|-----------------|
| `DETECTION_METHOD` | string | Detection method used | `libusb` |
| `USB_BUS` | number | USB bus number | 001-999 |
| `USB_DEVICE` | number | USB device number | 001-999 |
| `USB_SPEED` | number | USB speed in Mbps | 1.5, 12, 480, 5000, 10000, 20000 |
| `USB_VENDOR_PRODUCT` | string | USB VID:PID | Format: `xxxx:xxxx` (hex) |
| `USB_DESCRIPTION` | string | Device description | Free text from lsusb |
| `USB_DEVICE_PATH` | path | Full device path | `/dev/bus/usb/BBB/DDD` |

## Compatibility Notes

### Legacy Configuration Files

Older versions of the script (before merge) may have generated files without the `DETECTION_METHOD` field. To handle these:

```bash
source target_usb_c_port.env

# Detect method by checking which variables are set
if [[ -n "$TYPEC_PORT" ]]; then
    DETECTION_METHOD="sysfs"
elif [[ -n "$USB_BUS" ]]; then
    DETECTION_METHOD="libusb"
else
    echo "Error: Unknown configuration format"
    exit 1
fi
```

### Migration from Old Format

If you have an old configuration file, simply re-run the detection script:

```bash
sudo ./scripts/identify-usb-c-port.sh
```

This will generate a new configuration file with the `DETECTION_METHOD` field.

## Examples

### Example 1: sysfs Method Output

```bash
$ sudo ./scripts/identify-usb-c-port.sh
=== USB-C Port Identification Tool ===
=== Using Type-C sysfs Detection Method ===
...
The target USB-C port is: port1
  Path: /sys/class/typec/port1
  Data Role: host [device]
  Power Role: source [sink]
  Orientation: unknown

Configuration saved to: target_usb_c_port.env
```

Resulting file:
```bash
DETECTION_METHOD=sysfs
TYPEC_PORT=port1
TYPEC_PORT_PATH=/sys/class/typec/port1
TYPEC_DATA_ROLE=host [device]
TYPEC_POWER_ROLE=source [sink]
TYPEC_ORIENTATION=unknown
USB_CONTROLLER=unknown
```

### Example 2: libusb Method Output (Fallback)

```bash
$ sudo ./scripts/identify-usb-c-port.sh
=== USB-C Port Identification Tool ===
=== Using Type-C sysfs Detection Method ===
Error: No Type-C port state change detected.
Falling back to libusb device enumeration method...

=== Using libusb Device Enumeration Method ===
...
The target USB-C port is:
  Bus:     002
  Device:  003
  Speed:   480 Mbps
  ID:      1d6b:0002
  Info:    Linux Foundation 2.0 root hub

Configuration saved to: target_usb_c_port.env
```

Resulting file:
```bash
DETECTION_METHOD=libusb
USB_BUS=002
USB_DEVICE=003
USB_SPEED=480
USB_VENDOR_PRODUCT=1d6b:0002
USB_DESCRIPTION="Linux Foundation 2.0 root hub"
USB_DEVICE_PATH=/dev/bus/usb/002/003
```

## Troubleshooting

### Missing DETECTION_METHOD field

**Problem**: Old configuration file doesn't have this field.

**Solution**: Re-run the detection script to generate a new config.

### Unknown field values

**Problem**: Fields show "unknown" for some attributes.

**Solution**: This is normal. Some hardware doesn't expose all attributes. The script handles this gracefully.

### Conflicting method types

**Problem**: Configuration shows one method but you need the other.

**Solution**: Delete the config file and re-run detection under the desired conditions (cables connected/disconnected, gadget mode enabled/disabled).

---

**Format Version**: 1.0  
**Last Updated**: November 25, 2025  
**Script Version**: Unified v1.0
